# Tool Calling with Vercel AI SDK

The **Tool Calling** example demonstrates how to integrate external tools like weather APIs or email services into your chatbot.

## Prerequisites

1. Ensure the Vercel AI SDK is installed in your project. Refer to [Next.js Getting Started](https://sdk.vercel.ai/docs/getting-started/nextjs-app-router).

2. Set up the necessary API keys and environment variables for the Vercel AI SDK. Check the [Providers documentation](https://sdk.vercel.ai/docs/foundations/providers-and-models) for details.

3. Define tools for handling specific tasks, such as sending emails or fetching weather information. For example, tools like `sendEmail` and `getWeatherInformation` are used in this implementation.

## Explanation

This example uses the `streamText` function to process user messages and invoke tools dynamically. Tools can be used to perform specific tasks, such as sending emails or fetching weather data, based on user input. Additionally, tools like `askForConfirmation` allow for user interaction before executing certain actions.

## Code Example

### API Route

The following API route handles requests to generate responses using tool calling. It uses the `streamText` function with tools for sending emails, fetching weather data, and interacting with the user.

```typescript
import { google } from "@ai-sdk/google";
import { streamText, tool } from "ai";
import { z } from "zod";

export async function POST(req: Request) {
  const { messages } = await req.json();

  const systemMessage = `Be a positive assistant.
    Format for notion. Use titles and subtitles.
    Use emojis to make the conversation more engaging.

    If the user wants the weather of their location, ask for confirmation with the askForConfirmation tool before using the getLocation and getWeatherInformation tool.
  `;

  const result = streamText({
    model: google("gemini-2.0-flash-001"),
    system: systemMessage,
    messages: messages,
    maxSteps: 10,
    tools: {
      sendEmail: tool({
        description: "Send an email to a specified recipient",
        parameters: z.object({
          to: z.string().describe("Email address of the recipient"),
          subject: z.string().describe("Subject of the email"),
          message: z.string().describe("Body content of the email"),
        }),
        execute: async ({ to, subject, message }) => {
          return {
            status: "success",
            message: `Email sent to ${to} with subject "${subject}" and message "${message}"`,
          };
        },
      }),
      getWeatherInformation: tool({
        description: "Show the weather in a given city to the user",
        parameters: z.object({ city: z.string() }),
        execute: async ({ city }: { city: string }) => {
          const weatherOptions = ["sunny", "cloudy", "rainy", "snowy", "windy"];
          return weatherOptions[Math.floor(Math.random() * weatherOptions.length)];
        },
      }),
      askForConfirmation: tool({
        description: "Ask the user for confirmation.",
        parameters: z.object({
          message: z.string().describe("The message to ask for confirmation."),
        }),
      }),
      getLocation: tool({
        description: "Get the user location. Always use askForConfirmation before using this tool.",
        parameters: z.object({}),
        execute: async () => {
          const cities = ["New York", "Los Angeles", "Chicago", "San Francisco"];
          return cities[Math.floor(Math.random() * cities.length)];
        },
      }),
    },
    onError: (error) => {
      console.error("Error:", error);
    },
  });

  return result.toDataStreamResponse();
}
```

### Frontend Integration

The `ChatTools` component demonstrates how to integrate tool calling into a Next.js application. It uses the `useChat` hook to handle API requests and display the AI-generated responses, while dynamically invoking tools based on user input.

```tsx
"use client";

import { useChat } from "@ai-sdk/react";
import { Button, Card, Input } from "@/components/ui";
import { Send, CircleStop } from "lucide-react";
import { useEffect, useRef } from "react";
import ChatEmpty from "./chat-empty";
import ChatRoot from "./chat-root";
import { ChatQuickActions } from "./chat-quick-action";
import { Markdown } from "@/components/markdown";

const quickActions = [
  {
    section: "tool-calling",
    label: "Get the weather in Paris",
    value: "Get the weather in Paris",
  },
  {
    section: "tool-calling",
    label: "Get the weather at my current location",
    value: "Get the weather at my current location",
  },
  {
    section: "tool-calling",
    label: "Send mail to ...",
    value: "Send a mail to <email> with subject <subject> and message <message>",
  },
];

export function ChatTools() {
  const {
    error,
    messages,
    input,
    handleInputChange,
    handleSubmit,
    setInput,
    addToolResult,
    status,
    reload,
    stop,
  } = useChat({ api: "/api/chat/tools" });

  const messagesEndRef = useRef<HTMLDivElement>(null);

  useEffect(() => {
    if (messages.length && messagesEndRef.current) {
      messagesEndRef.current.scrollIntoView({ behavior: "smooth" });
    }
  }, [messages]);

  return (
    <ChatRoot>
      <Card className="flex-1 overflow-y-auto flex flex-col mb-4">
        <div className={`flex-1 p-4 ${messages.length > 0 ? "space-y-4" : ""}`}>
          {messages.length === 0 && (
            <div className="h-full flex items-center justify-center">
              <ChatEmpty />
            </div>
          )}

          {messages.map((message, i) => (
            <div key={i} className={`flex gap-4 ${message.role === "user" ? "justify-end" : "justify-start"}`}>
              <div className={`rounded-lg px-4 ${message.role === "user" ? "bg-primary text-primary-foreground" : "bg-gray-200"}`}>
                {message.parts.map((part, index) => {
                  switch (part.type) {
                    case "text":
                      return <Markdown key={index}>{part.text}</Markdown>;
                    case "tool-invocation":
                      if (part.toolInvocation.toolName === "askForConfirmation") {
                        return (
                          <div key={index}>
                            {part.toolInvocation.args.message}
                            <div className="flex gap-2 mt-2">
                              <Button onClick={() => addToolResult({ toolCallId: part.toolInvocation.toolCallId, result: "Yes" })}>
                                Yes
                              </Button>
                              <Button onClick={() => addToolResult({ toolCallId: part.toolInvocation.toolCallId, result: "No" })}>
                                No
                              </Button>
                            </div>
                          </div>
                        );
                      }
                      return null;
                    default:
                      return null;
                  }
                })}
              </div>
            </div>
          ))}

          {error && (
            <div className="mt-4">
              <p className="text-red-500">An error occurred.</p>
              <button onClick={reload} className="text-blue-500">
                Retry
              </button>
            </div>
          )}
          <div ref={messagesEndRef} />
        </div>
      </Card>

      <ChatQuickActions quickActions={quickActions} setInput={setInput} />

      <form onSubmit={handleSubmit} className="flex gap-2">
        <Input value={input} onChange={handleInputChange} placeholder="Ask me something..." className="flex-1" />
        {status === "streaming" ? (
          <Button onClick={stop}>
            <CircleStop />
          </Button>
        ) : (
          <Button type="submit">
            <Send />
          </Button>
        )}
      </form>
    </ChatRoot>
  );
}
```

## Use Case

This example is ideal for applications that require dynamic tool integration, such as:

- Fetching weather information
- Sending emails
- Interacting with users for confirmation before executing actions

By using tools, you can extend the chatbot's functionality and provide a more interactive user experience.

## Quick Links

- [Vercel AI SDK Documentation](https://sdk.vercel.ai/docs)
- [Providers and Models](https://sdk.vercel.ai/docs/foundations/providers-and-models)
- [Tool Calling Documentation](https://sdk.vercel.ai/docs/ai-sdk-core/tools-and-tool-calling)